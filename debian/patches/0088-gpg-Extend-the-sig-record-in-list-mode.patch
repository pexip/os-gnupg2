From: Werner Koch <wk@gnupg.org>
Date: Thu, 12 Apr 2018 17:53:17 +0200
Subject: gpg: Extend the "sig" record in --list-mode.

* g10/getkey.c (get_user_id_string): Add arg R_NOUID.  Change call
callers.
(get_user_id): Add arg R_NOUID.  Change call callers.
* g10/mainproc.c (issuer_fpr_string): Make global.
* g10/keylist.c (list_keyblock_colon): Print a '?' for a missing key
also in --list-mode.  Print the "issuer fpr" field also if there is an
issuer fingerprint subpacket.
--

Scripts used to rely on the "User ID not found" string even in the
--with-colons listing.  However, that is not a good idea because that
string is subject to translations etc.  Now we have an explicit way of
telling that a key is missing.  For example:

  gpg --list-sigs --with-colons | \
    awk -F: '$1=="sig" && $2=="?" {if($13){print $13}else{print $5}}'

Prints all keyids or fingerprint of signing keys for which we do not
have the key in our local keyring.

Signed-off-by: Werner Koch <wk@gnupg.org>
(cherry picked from commit 69c3e7acb744e1e5606a4d946e3b948704cfbbae)
---
 doc/DETAILS      | 17 ++++++++++++++++-
 g10/getkey.c     | 21 ++++++++++++++-------
 g10/keydb.h      |  2 +-
 g10/keyedit.c    |  2 +-
 g10/keylist.c    | 15 ++++++++++++---
 g10/mainproc.c   |  5 +++--
 g10/packet.h     |  2 ++
 g10/passphrase.c |  2 +-
 g10/pkclist.c    |  2 +-
 g10/revoke.c     |  2 +-
 10 files changed, 52 insertions(+), 18 deletions(-)

diff --git a/doc/DETAILS b/doc/DETAILS
index ac599fc62..82be44324 100644
--- a/doc/DETAILS
+++ b/doc/DETAILS
@@ -105,6 +105,19 @@ described here.
     certificate (i.e. for the trust anchor) and an 'f' for all other
     valid certificates.
 
+    In "sig" records, this field may have one of these values as first
+    character:
+
+    - ! :: Signature is good.
+    - - :: Signature is bad.
+    - ? :: No public key to verify signature or public key is not usable.
+    - % :: Other error verifying a signature
+
+    More values may be added later.  The field may also be empty if
+    gpg has been invoked in a non-checking mode (--list-sigs) or in a
+    fast checking mode.  Since 2.2.7 '?' will also be printed by the
+    command --list-sigs if the key is not in the local keyring.
+
 *** Field 3 - Key length
 
     The length of key in bits.
@@ -193,9 +206,11 @@ described here.
     gpg's --edit-key menu does.
 
     For "sig" records, this is the fingerprint of the key that issued
-    the signature.  Note that this is only filled in if the signature
+    the signature.  Note that this may only be filled if the signature
     verified correctly.  Note also that for various technical reasons,
     this fingerprint is only available if --no-sig-cache is used.
+    Since 2.2.7 this field will also be set if the key is missing but
+    the signature carries an issuer fingerprint as meta data.
 
 *** Field 14 - Flag field
 
diff --git a/g10/getkey.c b/g10/getkey.c
index bb31dfbe0..5b6bb140f 100644
--- a/g10/getkey.c
+++ b/g10/getkey.c
@@ -3952,15 +3952,20 @@ enum_secret_keys (ctrl_t ctrl, void **context, PKT_public_key *sk)
  *********************************************/
 
 /* Return a string with a printable representation of the user_id.
- * this string must be freed by xfree.   */
+ * this string must be freed by xfree.  If R_NOUID is not NULL it is
+ * set to true if a user id was not found; otherwise to false.  */
 static char *
-get_user_id_string (u32 * keyid, int mode, size_t *r_len)
+get_user_id_string (u32 * keyid, int mode, size_t *r_len,
+                    int *r_nouid)
 {
   user_id_db_t r;
   keyid_list_t a;
   int pass = 0;
   char *p;
 
+  if (r_nouid)
+    *r_nouid = 0;
+
   /* Try it two times; second pass reads from the database.  */
   do
     {
@@ -4007,6 +4012,8 @@ get_user_id_string (u32 * keyid, int mode, size_t *r_len)
   else
     p = xasprintf ("%s [?]", keystr (keyid));
 
+  if (r_nouid)
+    *r_nouid = 1;
   if (r_len)
     *r_len = strlen (p);
   return p;
@@ -4016,7 +4023,7 @@ get_user_id_string (u32 * keyid, int mode, size_t *r_len)
 char *
 get_user_id_string_native (u32 * keyid)
 {
-  char *p = get_user_id_string (keyid, 0, NULL);
+  char *p = get_user_id_string (keyid, 0, NULL, NULL);
   char *p2 = utf8_to_native (p, strlen (p), 0);
   xfree (p);
   return p2;
@@ -4026,15 +4033,15 @@ get_user_id_string_native (u32 * keyid)
 char *
 get_long_user_id_string (u32 * keyid)
 {
-  return get_user_id_string (keyid, 1, NULL);
+  return get_user_id_string (keyid, 1, NULL, NULL);
 }
 
 
 /* Please try to use get_user_byfpr instead of this one.  */
 char *
-get_user_id (u32 * keyid, size_t * rn)
+get_user_id (u32 *keyid, size_t *rn, int *r_nouid)
 {
-  return get_user_id_string (keyid, 2, rn);
+  return get_user_id_string (keyid, 2, rn, r_nouid);
 }
 
 
@@ -4043,7 +4050,7 @@ char *
 get_user_id_native (u32 * keyid)
 {
   size_t rn;
-  char *p = get_user_id (keyid, &rn);
+  char *p = get_user_id (keyid, &rn, NULL);
   char *p2 = utf8_to_native (p, rn, 0);
   xfree (p);
   return p2;
diff --git a/g10/keydb.h b/g10/keydb.h
index c9f5b1c4a..0bc9e309a 100644
--- a/g10/keydb.h
+++ b/g10/keydb.h
@@ -374,7 +374,7 @@ void merge_keys_and_selfsig (kbnode_t keyblock);
 
 char*get_user_id_string_native( u32 *keyid );
 char*get_long_user_id_string( u32 *keyid );
-char*get_user_id( u32 *keyid, size_t *rn );
+char*get_user_id( u32 *keyid, size_t *rn, int *r_nouid);
 char*get_user_id_native( u32 *keyid );
 char *get_user_id_byfpr (const byte *fpr, size_t *rn);
 char *get_user_id_byfpr_native (const byte *fpr);
diff --git a/g10/keyedit.c b/g10/keyedit.c
index a477e92c4..69946ea13 100644
--- a/g10/keyedit.c
+++ b/g10/keyedit.c
@@ -269,7 +269,7 @@ print_one_sig (int rc, KBNODE keyblock, KBNODE node,
       else
 	{
 	  size_t n;
-	  char *p = get_user_id (sig->keyid, &n);
+	  char *p = get_user_id (sig->keyid, &n, NULL);
 	  tty_print_utf8_string2 (NULL, p, n,
 				  opt.screen_columns - keystrlen () - 26 -
 				  ((opt.
diff --git a/g10/keylist.c b/g10/keylist.c
index 1998ee9aa..92234ec47 100644
--- a/g10/keylist.c
+++ b/g10/keylist.c
@@ -1114,7 +1114,7 @@ list_keyblock_print (ctrl_t ctrl, kbnode_t keyblock, int secret, int fpr,
 	  else if (!opt.fast_list_mode)
 	    {
 	      size_t n;
-	      char *p = get_user_id (sig->keyid, &n);
+              char *p = get_user_id (sig->keyid, &n, NULL);
 	      print_utf8_buffer (es_stdout, p, n);
 	      xfree (p);
 	    }
@@ -1430,6 +1430,7 @@ list_keyblock_colon (ctrl_t ctrl, kbnode_t keyblock,
 	  byte fparray[MAX_FINGERPRINT_LEN];
           char *siguid;
           size_t siguidlen;
+          char *issuer_fpr = NULL;
 
 	  if (sig->sig_class == 0x20 || sig->sig_class == 0x28
 	      || sig->sig_class == 0x30)
@@ -1487,11 +1488,16 @@ list_keyblock_colon (ctrl_t ctrl, kbnode_t keyblock,
 	  else
 	    {
 	      rc = 0;
-	      sigrc = ' ';
+	      sigrc = ' '; /* Note the fix-up below in --list-sigs mode.  */
 	    }
 
 	  if (sigrc != '%' && sigrc != '?' && !opt.fast_list_mode)
-            siguid = get_user_id (sig->keyid, &siguidlen);
+            {
+              int nouid;
+              siguid = get_user_id (sig->keyid, &siguidlen, &nouid);
+              if (!opt.check_sigs && nouid)
+                sigrc = '?';  /* No key in local keyring.  */
+            }
           else
             {
               siguid = NULL;
@@ -1530,6 +1536,8 @@ list_keyblock_colon (ctrl_t ctrl, kbnode_t keyblock,
 	      for (i = 0; i < fplen; i++)
 		es_fprintf (es_stdout, "%02X", fparray[i]);
 	    }
+          else if ((issuer_fpr = issuer_fpr_string (sig)))
+            es_fputs (issuer_fpr, es_stdout);
 
 	  es_fprintf (es_stdout, ":::%d:\n", sig->digest_algo);
 
@@ -1538,6 +1546,7 @@ list_keyblock_colon (ctrl_t ctrl, kbnode_t keyblock,
 
 	  /* fixme: check or list other sigs here */
           xfree (siguid);
+          xfree (issuer_fpr);
 	}
     }
 
diff --git a/g10/mainproc.c b/g10/mainproc.c
index 79ad8d5a2..ec6975fe1 100644
--- a/g10/mainproc.c
+++ b/g10/mainproc.c
@@ -1187,7 +1187,7 @@ list_node (CTX c, kbnode_t node)
 	}
       else if (!opt.fast_list_mode)
         {
-          p = get_user_id (sig->keyid, &n);
+          p = get_user_id (sig->keyid, &n, NULL);
           es_write_sanitized (es_stdout, p, n,
                               opt.with_colons?":":NULL, NULL );
           xfree (p);
@@ -1585,7 +1585,8 @@ akl_has_wkd_method (void)
 
 /* Return the ISSUER fingerprint string in human readbale format if
  * available.  Caller must release the string.  */
-static char *
+/* FIXME: Move to another file.  */
+char *
 issuer_fpr_string (PKT_signature *sig)
 {
   const byte *p;
diff --git a/g10/packet.h b/g10/packet.h
index 9780d939e..b865502a3 100644
--- a/g10/packet.h
+++ b/g10/packet.h
@@ -581,6 +581,8 @@ int proc_signature_packets_by_fd (ctrl_t ctrl,
 int proc_encryption_packets (ctrl_t ctrl, void *ctx, iobuf_t a);
 int list_packets( iobuf_t a );
 
+char *issuer_fpr_string (PKT_signature *sig);
+
 /*-- parse-packet.c --*/
 
 /* Sets the packet list mode to MODE (i.e., whether we are dumping a
diff --git a/g10/passphrase.c b/g10/passphrase.c
index fde3ee4b5..f42c1874f 100644
--- a/g10/passphrase.c
+++ b/g10/passphrase.c
@@ -487,7 +487,7 @@ gpg_format_keydesc (PKT_public_key *pk, int mode, int escaped)
                && pk->keyid[1] != pk->main_keyid[1]);
   algo_name = openpgp_pk_algo_name (pk->pubkey_algo);
   timestr = strtimestamp (pk->timestamp);
-  uid = get_user_id (is_subkey? pk->main_keyid:pk->keyid, &uidlen);
+  uid = get_user_id (is_subkey? pk->main_keyid:pk->keyid, &uidlen, NULL);
 
   orig_codeset = i18n_switchto_utf8 ();
 
diff --git a/g10/pkclist.c b/g10/pkclist.c
index 288affc13..5ca5cc577 100644
--- a/g10/pkclist.c
+++ b/g10/pkclist.c
@@ -1151,7 +1151,7 @@ build_pk_list (ctrl_t ctrl, strlist_t rcpts, PK_LIST *ret_pk_list)
                   else
                     {
                       size_t n;
-                      char *p = get_user_id( keyid, &n );
+                      char *p = get_user_id( keyid, &n, NULL);
                       tty_print_utf8_string( p, n );
                       xfree(p);
                     }
diff --git a/g10/revoke.c b/g10/revoke.c
index 591b641d3..9d4a50158 100644
--- a/g10/revoke.c
+++ b/g10/revoke.c
@@ -557,7 +557,7 @@ gen_standard_revoke (PKT_public_key *psk, const char *cache_nonce)
 
   kl = opt.keyid_format == KF_NONE? 0 : keystrlen ();
 
-  tmpstr = get_user_id (keyid, &len);
+  tmpstr = get_user_id (keyid, &len, NULL);
   es_fprintf (memfp, "uid%*s%.*s\n\n",
               kl + 10, "",
               (int)len, tmpstr);
